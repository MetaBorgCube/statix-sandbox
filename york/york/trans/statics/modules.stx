module statics/modules

imports signatures/modules-sig
imports statics/modules-sig
imports statics/core-sig
imports statics/names
imports statics/base
imports statics/path

signature
  constructors
    SIG : scope -> TYPE
    FUNCTOR : ID * TYPE * TYPE -> TYPE
    ABS : TYPE
    
rules

  specOk : scope * Spec -> scope

  specOk(s1, ValSig(x, t)) = s2 :- {T}
    new s2, s2 -P-> s1,
    typeOfValType(s1, t) == T, 
    declareID(s2, x, withType(T)).
  
  specOk(s1, TypeSig(x, td)) = s2 :- {K TD}
    new s2, s2 -P-> s1,
    declareID(s2, x, withType(TD)).
  
  specOk(s1, AbsTypeSig(x)) = s2 :- {K TD}
    new s2, s2 -P-> s1,
    declareID(s2, x, withType(ABS())).
    
  specOk(s1, ModSig(x, mt)) = s2 :- {MT}
    new s2, s2 -P-> s1,
    typeOfModType(s1, mt) == MT,
    declareID(s2, x, withType(MT)).
    
  specsOk : scope * list(Spec) -> scope
  
  specsOk(s, []) = s.
  
  specsOk(s1, [spec | specs]) = 
    specsOk(specOk(s1, spec), specs).
  
rules 

  typeOfModType : scope * ModType -> TYPE

  typeOfModType(s, Sig(specs)) = SIG(specsOk(s, specs)). 
    // problem: s reachable from s_sig
  
  typeOfModType(s, FunctorType(x, mt1, mt2)) = FUNCTOR(x, MT1, MT2) :-
    typeOfModType(s, mt1) == MT1,
    typeOfModType(s, mt2) == MT2.
  

  
  proj(SIG(s), x) = typeOfID(s, x).
  
  // it is an error to project on a functor?
  
rules 

  typeOfModTerm : scope * ModTerm -> TYPE
  
  typeOfModTerm(s, LongIdent(p)) = typeOfPath(s, p).
  
  typeOfModTerm(s, Struct(defs)) = SIG(s_sig) :-
    defsOk(s, defs) == s_sig.
  
  typeOfModTerm(s, Functor(x, mt1, mtrm)) = FUNCTOR(x, T1, T2) :-
    typeOfModType(s, mt1) == T1,
    typeOfModTerm(s, mtrm) == T2.
  
  typeOfModTerm(s, Apply(mtrm1, mtrm2)) = T2 :- {x T1 T3}
    typeOfModTerm(s, mtrm1) == FUNCTOR(x, T1, T2),
    typeOfModTerm(s, mtrm2) == T3.
    // TODO: substitution in type
  
  typeOfModTerm(s, Constraint(mtrm, mt)) = T2 :- {T1}
    typeOfModTerm(s, mtrm) == T1,
    typeOfModType(s, mt) == T2.
    // TODO: check compatability
  
rules

  defOk : scope * Def -> scope
  
  defOk(s1, ValueStr(x, e)) = s2 :- {T}
    new s2, s2 -P-> s1,
    typeOfTerm(s1, e) == T,
    declareID(s2, x, withType(T)).
    
  defOk(s1, TypeKindStr(x, k, deft)) = s2 :- {T}
    new s2, s2 -P-> s1,
    typeOfDefType(s1, deft) == T,
    declareID(s2, x, withType(T)).
  
  defOk(s1, TypeStr(x, deft)) = s2 :- {T}
    new s2, s2 -P-> s1,
    typeOfDefType(s1, deft) == T,
    declareID(s2, x, withType(T)).
  
  defOk(s1, ModuleStr(x, mtrm)) = s2 :- {T}
    new s2, s2 -P-> s1,
    typeOfModTerm(s1, mtrm) == T,
    declareID(s2, x, withType(T)).
  
  defsOk : scope * list(Def) -> scope
  
  defsOk(s, []) = s.
  
  defsOk(s1, [def | defs]) = s3 :- {s2}
    defOk(s1, def) == s2,
    defsOk(s2, defs) == s3.
  
  
  
  